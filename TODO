- Arrange memory allocations of delay buffers in effects.
- Complete list of assignable effect parameters to MIDI learn.

DSP TODO:
*This is a wish-list.  Some of these may not be done for 0.5.0.
- Reverse delay fade between old and new at wrap instead of ducking volume.  It will sound more smooth :)
- Improve sub-octave modulator for distortion.  Perhaps this can be a new effect.
- Dynamic echo:  Delay time changes with input signal dynamics....possible to get a "bouncing ball" effect.
- Vocoder
- CPU-friendly pitch shifter, flexible for Whammy effect
- Synth filters
- Sample/Hold modulator -- maybe just add to LFO effect using random sequence.
- 8-step sequencer effect.  Invoke phaser, flanger, wah and volume modulation.  Perhaps this can be a global variable with a GUI front-end?
- Ring modulator + arpeggiated carrier.
- Upsampling option for distortions and waveshapers.
- Distortion pedal & preamp modeling series:  Ibanez Tubescreamer, Thrash metal, Boss Metal Zone, DOD Death metal, MXR Dist +, some tube preamps ...  
- Infinite series:  i.e. Barberpole phaser, flanger and maybe some unique comb filter types.

Plugin List:
Tim Goetze CAPS Plugins
- Plate Reverb
- AmpVTS tube amp with tone stack circuit.
- Cabinet II 
- Scape -- Fractal modulated stereo delay...Maybe we could add the fractal modulation to existing delay effect if easier...
- Lorenz attractor as a modulation source "lfo" for phasers, flangers, chorus, etc.

Here is the source for the Lorenz attractor from http://local.wasp.uwa.edu.au/~pbourke/fractals/lorenz/
x, y, and z are 3-dimentional coordinates.  These could be mapped to various paramters within an effect...
C source

#include "stdio.h"
#include "stdlib.h"
#include "math.h"

#define N 10000

int main(int argc,char **argv)
{
   int i=0;
   double x0,y0,z0,x1,y1,z1;
   double h = 0.01;
   double a = 10.0;
   double b = 28.0;
   double c = 8.0 / 3.0;

   x0 = 0.1;
   y0 = 0;
   z0 = 0;
   for (i=0;i<N;i++) {
      x1 = x0 + h * a * (y0 - x0);
      y1 = y0 + h * (x0 * (b - z0) - y0);
      z1 = z0 + h * (x0 * y0 - c * z0);
      x0 = x1;
      y0 = y1;
      z0 = z1;
      if (i > 100)
         printf("%d %g %g %g\n",i,x0,y0,z0);
   }
}

